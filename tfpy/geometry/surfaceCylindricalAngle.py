#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# surfaceCylindricalAngle.py


import numpy as np 
import matplotlib.pyplot as plt 
from .surface import Surface
from ..toroidalField import ToroidalField 
from typing import Tuple, Dict, List


class Surface_cylindricalAngle(Surface):

    def __init__(self, r: ToroidalField, z: ToroidalField, reverseToroidalAngle: bool=True) -> None:
        super().__init__(r, z)
        self.reverseToroidalAngle = reverseToroidalAngle 

    @property
    def stellSym(self) -> bool:
        return (not self.r.imIndex) and (not self.z.reIndex) 

    def changeStellSym(self, stellSym: bool) -> None: 
        self.r.reIndex, self.z.imIndex = True, True 
        if stellSym: 
            self.r.imIndex, self.z.reIndex = False, False 
        else: 
            self.r.imIndex, self.z.reIndex = True, True 

    @property
    def metric(self):
        g_thetatheta = self.dRdTheta*self.dRdTheta + self.dZdTheta*self.dZdTheta
        g_thetazeta = self.dRdTheta*self.dRdZeta + self.dZdTheta*self.dZdZeta
        g_zetazeta = self.dRdZeta*self.dRdZeta + self.r*self.r + self.dZdZeta*self.dZdZeta
        return g_thetatheta, g_thetazeta, g_zetazeta 

    def getRZ(self, thetaGrid: np.ndarray, zetaGrid: np.ndarray) -> Tuple[np.ndarray]: 
        if self.reverseToroidalAngle: 
            zetaGrid = -zetaGrid
        rArr = self.r.getValue(thetaGrid, zetaGrid)
        zArr = self.z.getValue(thetaGrid, zetaGrid)
        return rArr, zArr
    
    def getXYZ(self, thetaGrid: np.ndarray, zetaGrid: np.ndarray) -> Tuple[np.ndarray]: 
        if self.reverseToroidalAngle: 
            zetaGrid = -zetaGrid
        rArr = self.r.getValue(thetaGrid, zetaGrid)
        zArr = self.z.getValue(thetaGrid, zetaGrid)
        xArr = rArr * np.cos(zetaGrid)
        yArr = rArr * np.sin(zetaGrid)
        return xArr, yArr, zArr
    
    def plot_crosssection(self, phiarr: List, labelarr: List=None, ax=None):
        if ax is None:
            fig, ax = plt.subplots()
        for phiindex, phi in enumerate(phiarr):
            try:
                label = labelarr[phiindex]
            except:
                label = '_nolegend_'
            phiarr = np.ones(100) * phi
            thetaarr = np.linspace(0, 2*np.pi, 100)
            rarr, zarr = self.getRZ(thetaarr, phiarr)
            ax.plot(rarr, zarr, label=label)
            ax.set_xlabel(r'$R$', fontsize=18)
            ax.set_ylabel(r'$Z$', fontsize=18)
            ax.tick_params(axis='both', which='both', labelsize=18)
            ax.legend(fontsize=16)
            plt.axis("equal")
        return fig

    def plot_plt(self, ntheta: int=360, nzeta: int=360, fig=None, ax=None, **kwargs): 
        if ax is None: 
            fig = plt.figure()
            ax = fig.add_subplot(111, projection="3d")
        plt.sca(ax) 
        thetaArr = np.linspace(0, 2*np.pi, ntheta) 
        zetaArr = np.linspace(0, 2*np.pi, nzeta) 
        if self.reverseToroidalAngle:
            zetaArr = -zetaArr
        thetaGrid, zetaGrid = np.meshgrid(thetaArr, zetaArr) 
        rArr = self.r.getValue(thetaGrid, zetaGrid)
        zArr = self.z.getValue(thetaGrid, zetaGrid)
        xArr = rArr * np.cos(zetaGrid)
        yArr = rArr * np.sin(zetaGrid)
        ax.plot_surface(xArr, yArr, zArr, color="coral") 
        plt.axis("equal")
        return fig

    def toVTK(self, vtkname, mpol: int=360, ntor: int=360, **kwargs): 
        from pyevtk.hl import gridToVTK
        thetaArr, zetaArr = np.linspace(0, 2*np.pi, mpol), np.linspace(0, 2*np.pi, ntor*self.nfp)
        zetaGrid, thetaGrid = np.meshgrid(zetaArr, thetaArr)
        xGrid, yGrid, zGrid = self.getXYZ(thetaGrid, zetaGrid)
        gridToVTK(
            vtkname, 
            xGrid.reshape((1, mpol, ntor*self.nfp)), 
            yGrid.reshape((1, mpol, ntor*self.nfp)), 
            zGrid.reshape((1, mpol, ntor*self.nfp)), 
            pointData = kwargs
        )

    def toVacuumVMEC(self, fileName: str='vacuum', params: Dict=dict()) -> None: 
        
        if "lasym" not in params.keys():
            params["lasym"] = True 
        if "phiedge" not in params.keys():
            params["phiedge"] = 1.0 
        if "delt" not in params.keys():
            params["delt"] = 0.75 
        if "niter" not in params.keys():
            params["niter"] = 20000 
        if "nstep" not in params.keys():
            params["nstep"] = 200 
        if "ns_array" not in params.keys():
            params["ns_array"] = [32, 64, 128] 
        if "ftol_array" not in params.keys():
            params["ftol_array"] = [1e-8, 1e-10, 1e-12] 
        if 'input' not in fileName:
            fileName = 'input.'+fileName
        with open(fileName, 'w+') as f:
            f.write("! This &INDATA namelist was generated by tfpy.geometry.Surface_cylindricalAngle \n")
            f.write("&INDATA \n")
            f.write("   LFREEB = F \n") 
            f.write("!----- Grid Parameters ----- \n") 
            if params["lasym"]:
                f.write("   LASYM = F \n") 
            else:
                f.write("   LASYM = T \n") 
            f.write("   NFP = " + str(self.nfp) + " \n")
            f.write("   MPOL = " + str(self.mpol+1) + " \n")
            f.write("   NTOR = " + str(self.ntor) + " \n")
            f.write("   PHIEDGE = " + str(params["phiedge"]) + " \n")
            f.write("!----- Runtime Parameters ----- \n") 
            f.write("   DELT = " + str(params["delt"]) + " \n") 
            f.write("   NITER = " + str(params["niter"]) + " \n") 
            f.write("   NSTEP = " + str(params["nstep"]) + " \n") 
            f.write("   NS_ARRAY = " + str(params["ns_array"])[1:-1] + " \n") 
            f.write("   FTOL_ARRAY = " + str(params["ftol_array"])[1:-1] + " \n") 
            f.write("!----- Pressure Parameters ----- \n") 
            f.write("   AM = 0.0 0.0 \n")
            f.write("!----- Current/Iota Parameters ----- \n") 
            f.write("   NCURR = 1 \n") 
            f.write("   CURTOR = 0.0 \n") 
            f.write("   AC = 0.0 0.0 \n") 
            f.write("!----- Boundary Parameters ----- \n") 
            for i in range((2*self.ntor+1)*self.mpol+self.ntor+1): 
                m, n = self.r.indexReverseMap(i)
                if not self.reverseToroidalAngle:
                    n = -n
                if m==0 and n==0:
                    f.write("   RBC("+str(n)+","+str(m)+")="+"{:.14e}".format(self.r.getRe(m,n)))
                    f.write("   ZBS("+str(n)+","+str(m)+")="+"{:.14e}".format(-self.z.getIm(m,n)))
                    if params["lasym"]:
                        f.write(" \n") 
                    else:
                        f.write("   RBS("+str(n)+","+str(m)+")="+"{:.14e}".format(-self.r.getIm(m,n)))
                        f.write("   ZBC("+str(n)+","+str(m)+")="+"{:.14e}".format(self.z.getRe(m,n)) + " \n")
                else:
                    f.write("   RBC("+str(n)+","+str(m)+")="+"{:.14e}".format(2*self.r.getRe(m,n)))
                    f.write("   ZBS("+str(n)+","+str(m)+")="+"{:.14e}".format(-2*self.z.getIm(m,n)))
                    if params["lasym"]:
                        f.write(" \n") 
                    else:
                        f.write("   RBS("+str(n)+","+str(m)+")="+"{:.14e}".format(-2*self.r.getIm(m,n)))
                        f.write("   ZBC("+str(n)+","+str(m)+")="+"{:.14e}".format(2*self.z.getRe(m,n)) + " \n")
            f.write("/ \n")

    def toVacuumSPEC(self, fileName: str, params: Dict=dict()) -> None: 
        
        if "phiedge" not in params.keys():
            params["phiedge"] = 1.0 
        
        if 'sp' not in fileName:
            fileName = fileName+".sp"
        with open(fileName, 'w+') as file:
            # physicslist
            file.write("&physicslist\n")
            file.write("    " + "{:12} = {:d}".format("igeometry",   3) + "\n")
            file.write("    " + "{:12} = {:d}".format("istellsym",   1) + "\n")
            file.write("    " + "{:12} = {:d}".format("lfreebound",  0) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("phiedge", params["phiedge"]) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("curtor", 0) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("curpol", 0) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("gamma", 0) + "\n")
            file.write("    " + "{:12} = {:d}".format("nfp",  self.nfp) + "\n")
            file.write("    " + "{:12} = {:d}".format("nvol", 1) + "\n")
            file.write("    " + "{:12} = {:d}".format("mpol", self.mpol) + "\n")
            file.write("    " + "{:12} = {:d}".format("ntor", self.ntor) + "\n")
            file.write("    " + "{:12} = {:d}".format("lrad", 8) + "\n")
            file.write("    " + "{:12} = {:d}".format("lconstraint", 0) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("tflux", 1.0) + "\n")
            for index in range(len(self.r.reArr)):
                m, n = self.r.indexReverseMap(index)
                if m==0 and n==0:
                    file.write("{:<32}".format("    {:12} = ".format("rbc(" + str(n) + ", " + str(m) + ")" ) + "{:-.5e}".format(self.r.reArr[index])))
                    file.write("{:<32}".format("    {:12} = ".format("zbs(" + str(n) + ", " + str(m) + ")" ) + "{:-.5e}".format(-self.z.imArr[index])))
                    file.write("{:<32}".format("    {:12} = ".format("rbs(" + str(n) + ", " + str(m) + ")" ) + "{:-.5e}".format(-self.r.imArr[index])))
                    file.write("{:<32}".format("    {:12} = ".format("zbc(" + str(n) + ", " + str(m) + ")" ) + "{:-.5e}".format(self.z.reArr[index])))
                    file.write("\n")
                else:
                    file.write("{:<32}".format("    {:12} = ".format("rbc(" + str(n) + ", " + str(m) + ")" ) + "{:-.5e}".format(2*self.r.reArr[index])))
                    file.write("{:<32}".format("    {:12} = ".format("zbs(" + str(n) + ", " + str(m) + ")" ) + "{:-.5e}".format(-2*self.z.imArr[index])))
                    file.write("{:<32}".format("    {:12} = ".format("rbs(" + str(n) + ", " + str(m) + ")" ) + "{:-.5e}".format(-2*self.r.imArr[index])))
                    file.write("{:<32}".format("    {:12} = ".format("zbc(" + str(n) + ", " + str(m) + ")" ) + "{:-.5e}".format(2*self.z.reArr[index])))
                    file.write("\n")
            file.write("    " + "{:12} = {:-.5e}".format("mupftol", 1e-14) + "\n")
            file.write("    " + "{:12} = {:d}".format("mupfits",   8) + "\n")
            file.write("/\n")
            file.write("\n")

            # numericlist
            file.write("&numericlist\n")
            file.write("    " + "{:12} = {:d}".format("ndiscrete",   2) + "\n")
            file.write("    " + "{:12} = {:d}".format("nquad",      -1) + "\n")
            file.write("    " + "{:12} = {:d}".format("impol",      -4) + "\n")
            file.write("    " + "{:12} = {:d}".format("intor",      -4) + "\n")
            file.write("    " + "{:12} = {:d}".format("lsparse",     0) + "\n")
            file.write("    " + "{:12} = {:d}".format("lsvdiota",    0) + "\n")
            file.write("    " + "{:12} = {:d}".format("imethod",     3) + "\n")
            file.write("    " + "{:12} = {:d}".format("iorder",      2) + "\n")
            file.write("    " + "{:12} = {:d}".format("iprecon",     0) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("iotatol", -1.0) + "\n")
            file.write("/\n")
            file.write("\n")

            # locallist
            file.write("&locallist\n")
            file.write("    " + "{:12} = {:d}".format("lbeltrami", 4) + "\n")
            file.write("    " + "{:12} = {:d}".format("linitgues", 1) + "\n")
            file.write("/\n")
            file.write("\n")

            # globallist
            file.write("&globallist\n")
            file.write("    " + "{:12} = {:d}".format("lfindzero", 2) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("escale", 0.0) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("pcondense", 4.0) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("forcetol", 1e-10) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("c05xtol", 1e-12) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("c05factor", 1e-2) + "\n")
            file.write("    " + "{:12} = .true.".format("lreadgf") + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("opsilon", 1.0) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("epsilon", 0.0) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("upsilon", 1.0) + "\n")
            file.write("/\n")
            file.write("\n")

            # diagnosticslist
            file.write("&diagnosticslist\n")
            file.write("    " + "{:12} = {:-.5e}".format("odetol", 1e-7) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("absreq", 1e-8) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("relreq", 1e-8) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("absacc", 1e-4) + "\n")
            file.write("    " + "{:12} = {:-.5e}".format("epsr",   1e-8) + "\n")
            file.write("    " + "{:12} = {:d}".format("nppts", 400) + "\n")
            file.write("    " + "{:12} = {:d}".format("nptrj", -1) + "\n")
            file.write("    " + "{:12} = .false.".format("lhevalues") + "\n")
            file.write("    " + "{:12} = .false.".format("lhevectors") + "\n")
            file.write("/\n")
            file.write("\n")

            # screenlist
            file.write("&screenlist\n")
            file.write("    " + "{:12} = .true.".format("wpp00aa") + "\n")
            file.write("/\n")
            file.write("\n")

    # class method #####################################################################################################################################################
    from qsc import Qsc
    @classmethod
    def fromQSC(cls, qsccase: Qsc, r: float, mpol: int=10, ntor: int=10):

        if qsccase.order != 'r1':
            print('TODO')
        
        thetaarr = np.linspace(0, -2*np.pi, 2*mpol+1, endpoint=False)
        phiarr = np.linspace(0, 2*np.pi/qsccase.nfp, 2*ntor+1, endpoint=False)
        phigrid, thetagrid = np.meshgrid(phiarr, thetaarr)

        qsccase.X1c_untwisted_spline = qsccase.convert_to_spline(qsccase.X1c_untwisted)
        qsccase.X1s_untwisted_spline = qsccase.convert_to_spline(qsccase.X1s_untwisted)
        qsccase.Y1c_untwisted_spline = qsccase.convert_to_spline(qsccase.Y1c_untwisted)
        qsccase.Y1s_untwisted_spline = qsccase.convert_to_spline(qsccase.Y1s_untwisted)

        def phi0_residual(phi0, phitarget):

            cosphi0, sinphi0 = np.cos(phi0).flatten(), np.sin(phi0).flatten()
            costheta, sintheta = np.cos(thetagrid).flatten(), np.sin(thetagrid).flatten()

            normal_r, normal_phi, normal_z = qsccase.normal_R_spline(phi0), qsccase.normal_phi_spline(phi0), qsccase.normal_z_spline(phi0)
            normal_x = normal_r * cosphi0 - normal_phi * sinphi0
            normal_y = normal_r * sinphi0 + normal_phi * cosphi0
            binormal_r, binormal_phi, binormal_z = qsccase.binormal_R_spline(phi0), qsccase.binormal_phi_spline(phi0), qsccase.binormal_z_spline(phi0)
            binormal_x = binormal_r * cosphi0 - binormal_phi * sinphi0
            binormal_y = binormal_r * sinphi0 + binormal_phi * cosphi0

            r0grid = qsccase.R0_func(phi0)
            z0grid = qsccase.Z0_func(phi0)
            X1grid = r * (qsccase.X1c_untwisted_spline(phi0) * costheta + qsccase.X1s_untwisted_spline(phi0) * sintheta)
            Y1grid = r * (qsccase.Y1c_untwisted_spline(phi0) * costheta + qsccase.Y1s_untwisted_spline(phi0) * sintheta)

            xgrid = r0grid * cosphi0 + X1grid * normal_x + Y1grid * binormal_x
            ygrid = r0grid * sinphi0 + X1grid * normal_y + Y1grid * binormal_y
            zgrid =           z0grid + X1grid * normal_z + Y1grid * binormal_z
            rgrid = np.sqrt(xgrid*xgrid + ygrid*ygrid)
            phigrid = np.arctan2(ygrid, xgrid)
            return phigrid - phitarget
        
        from scipy.optimize import root
        ans = root(phi0_residual, np.copy(phigrid), args=(phigrid.flatten()))
        phi0grid = ans.x.reshape(phigrid.shape)

        cosphi0, sinphi0 = np.cos(phi0grid), np.sin(phi0grid)
        costheta, sintheta = np.cos(thetagrid), np.sin(thetagrid)

        normal_r, normal_phi, normal_z = qsccase.normal_R_spline(phi0grid), qsccase.normal_phi_spline(phi0grid), qsccase.normal_z_spline(phi0grid)
        normal_x = normal_r * cosphi0 - normal_phi * sinphi0
        normal_y = normal_r * sinphi0 + normal_phi * cosphi0
        binormal_r, binormal_phi, binormal_z = qsccase.binormal_R_spline(phi0grid), qsccase.binormal_phi_spline(phi0grid), qsccase.binormal_z_spline(phi0grid)
        binormal_x = binormal_r * cosphi0 - binormal_phi * sinphi0
        binormal_y = binormal_r * sinphi0 + binormal_phi * cosphi0

        r0grid = qsccase.R0_func(phi0grid)
        z0grid = qsccase.Z0_func(phi0grid)
        X1grid = r * (qsccase.X1c_untwisted_spline(phi0grid) * costheta + qsccase.X1s_untwisted_spline(phi0grid) * sintheta)
        Y1grid = r * (qsccase.Y1c_untwisted_spline(phi0grid) * costheta + qsccase.Y1s_untwisted_spline(phi0grid) * sintheta)
        if qsccase.order != 'r1':
            print('TODO')

        xgrid = r0grid * cosphi0 + X1grid * normal_x + Y1grid * binormal_x
        ygrid = r0grid * sinphi0 + X1grid * normal_y + Y1grid * binormal_y
        zgrid =           z0grid + X1grid * normal_z + Y1grid * binormal_z
        rgrid = np.sqrt(xgrid*xgrid + ygrid*ygrid)
        newphigrid = np.arctan2(ygrid, xgrid)

        from tfpy.toroidalField import fftToroidalField
        return cls(
            fftToroidalField( rgrid, nfp=qsccase.nfp),
            fftToroidalField(-zgrid, nfp=qsccase.nfp),
            reverseToroidalAngle = False
        )
            



if __name__ == "__main__":
    pass
